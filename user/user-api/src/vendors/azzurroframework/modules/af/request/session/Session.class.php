<?php
/*
	RequestService session class

	Service that permits to log information into a file.


	Copyright 2017 Alessandro Pasqualini
	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at
    	http://www.apache.org/licenses/LICENSE-2.0
	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.

	@author    Alessandro Pasqualini <alessandro.pasqualini.1105@gmail.com>
	@url       https://github.com/alessandro1105
*/

	// Strict type hint
	declare(strict_types = 1);

	namespace AzzurroFramework\Modules\AF\Request\Session;

	use \Adbar\Dot; // Dot notation from composer package
	
	class Session {

		// Service config array
		private $config;

        // Session variables
        private $data;

		// Tells if the session has been generated by this request
		private $generated;

		// Contructor
		public function __construct($config) {

			// Save config array
			$this->config = $config;

			// Set that the session has not been generated
			$this->generated = false;

			// Create new Dot object
			$this->data = new Dot();
		}

		// Start the session
		public function start() {
			global $_COOKIE;

			// Ecevute only if the session is not active
			if (session_status() != PHP_SESSION_ACTIVE) {

				// Use strict mode for security reasons
				ini_set('session.use_strict_mode', 1);

				// Check if there is a cookie for the session (if not the session has not been started)
				if (!isset($_COOKIE['PHPSESSID'])) {
					// The session does not exist
					$this->generate();

				// There is a cookie session id, let's check if it is a valid session
				} else {
					$id = $_COOKIE['PHPSESSID'];
					$sessions = scandir($this->config['save_path']);

					// Check if the session exist
					if (array_search('sess_' . $id, $sessions)) {

						// Start the session
						session_start();

						// Save reference to the session variable
						global $_SESSION;
						$this->data->setReference($_SESSION);


						// Check if the session has been destroyed before
						if (isset($_SESSION['destroyed'])) {
							// Check if the session has gone into timeout
							if ($_SESSION['destroyed'] < time() - $this->config['timeout']) {
								// NOTE: Need to handle this event because it can be generated by an attack
								// Session must be destroyed and regenerate
								$this->destroy();
								// Generate a completely new session
								$this->generate();

							// Session has been destroyed but timeout has not been reached
							} else if ($_SESSION['session_id']) {
								// Save current session
								session_commit();
								// Load the new session (change the session id)
								session_id($_SESSION['session_id']);
								// Start the new session
								session_start();

								// Save reference to the session variable
								global $_SESSION;
								$this->data->setReference($_SESSION);
							}

						// Check if the session has expired
						} else if ($_SESSION['generation_time'] < time() - $this->config['expiration']) {
							// This has not been generated by an attack but just by a timeout event
							// The session has expired and has not been exchanged before, so we need to generate a new one
							// Destroy the current session
							$this->destroy();
							// Generate a completely new session
							$this->generate();

						// Check if it's time to renew the session id (The lifespan has been reached)
						} else if ($_SESSION['generation_time'] < time() - $this->config['lifespan']) {
							// The session lifespan has been reached it need to be regenerated
							$this->regenerate();
						}

					// Session fixation or the session is too old that the gc has collected it
					} else {
						// Start a new session
						$this->generate();
					}
				}
			}
		}

		// Destroy the current session (must be restarted manually)
		public function destroy() {
			// Unset all session variables
			session_unset();
			// Destroy the session
			session_destroy();

			// Setting that the session has not been generated (it has been destroyed)
			$this->generated = false;
		}

		// regenerate the session id (chain it with the current session)
		public function regenerate() {
			global $_SESSION;

			// If the session has not been generated by this request
			if (!$this->generated) {
				// Generate a new session id
				$id = session_create_id($this->config['prefix']);

				// Save all session variables
				$variables = array();
				foreach ($_SESSION as $key => $value) {
					$variables[$key] = $value;
				}

				// Save the new session id
				$_SESSION['session_id'] = $id;
				// Set destroy timestamp
				$_SESSION['destroyed'] = time();

				// Write and close current session;
				session_commit();

				// Disable strict session
				ini_set('session.use_strict_mode', 0);

				// Start session with new session ID
				session_id($id);
				// Start the new session
				session_start();

				// Save reference to the session variable
				global $_SESSION;				

				// Copy all session variables inside the new session
				foreach ($variables as $key => $value) {
					$_SESSION[$key] = $value;
				}

				// Change generation time
				$_SESSION['generation_time'] = time();

				$this->data->setReference($_SESSION);
			}

			//Setting that the session has been generated
			$this->generated = true;
		}

		// generate a new session (don't chain it with the current session)
		public function generate() {
			// If the session has not been generated by this request
			if (!$this->generated) {

				// Generate a new session id
				$id = session_create_id($this->config['prefix']);

				// Write and close current session;
				session_commit();

				// Disable strict session
				ini_set('session.use_strict_mode', 0);

				// Start session with new session ID
				session_id($id);

				// Start the new session
				session_start();

				// Save reference to the session variable
				global $_SESSION;

				// Set generation time
				$_SESSION['generation_time'] = time();

				$this->data->setReference($_SESSION);


			// The session has been generated but it is requested a new entirely session
			} else {
				// BUG: If the session has been regenerated, the previus session has indication to the current session
				// unset all properties other than generation time (clean up the session if it has been regenerated)
				foreach ($_SESSION as $key => $value) {
					if ($key != 'generation_time') {
						unset($_SESSION[$key]);
					}
				}
			}

			//Setting that the session has been generated
			$this->generated = true;
		}


		// Set session property
        public function put($key, $value) {
			$this->data->set($key, $value);
        }

		// Get session property
        public function get($key, $default) {
			//return $this->_SESSION[$key];
			return $this->data->has($key) ? $this->data->get($key) : $default;
        }

		// Check existance of session property
        public function has($key) {
            return $this->data->has($key);
        }

		// Destroy session property
        public function forget($key) {
			$this->data->delete($key);
        }
	}